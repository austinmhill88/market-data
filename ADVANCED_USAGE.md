# Advanced Usage Guide

## Understanding the Data Generation Process

### Price Generation Algorithm

The generator uses **Geometric Brownian Motion (GBM)**, which is the standard model for stock price evolution:

```
dS = μS dt + σS dW
```

Where:
- `S` = stock price
- `μ` = drift (expected return)
- `σ` = volatility
- `dW` = Wiener process (random walk)

This ensures:
- Prices are always positive
- Returns are log-normally distributed (realistic)
- Natural trending and mean reversion

### OHLC Generation

From the close prices generated by GBM, the generator creates realistic OHLC bars:

1. **Open**: Previous close + small random gap
2. **High/Low**: Generated to encompass open/close with realistic intrabar range
3. **Range**: Based on volatility and random variation

### Volume Generation

Volume uses a **log-normal distribution** which mirrors real market behavior:
- Most days have average volume
- Occasional high-volume spikes
- Never negative
- Generally inversely correlated with price

## Randomization Strategy

### Why Each Run is Different

Even without specifying a seed, each run produces unique data through:

1. **Microsecond Timestamp Seed**: Default seed uses `datetime.now().timestamp() * 1000000`
2. **Parameter Randomization**: All parameters randomized within realistic ranges
3. **Stochastic Processes**: Multiple layers of random number generation

### Controlling Randomization

```bash
# Fully random (different every time)
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365

# Reproducible (same every time with same seed)
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365 --seed 42

# Semi-controlled (specify some parameters, randomize others)
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365 \
  --start-price 150 --volatility 0.25
  # drift and volume will still be random
```

## Advanced Scenarios

### 1. Creating Different Market Regimes

**Bull Market:**
```bash
python generate_market_data.py --symbols BULL --timeframe 1Day --days 365 \
  --drift 0.15 --volatility 0.20
```

**Bear Market:**
```bash
python generate_market_data.py --symbols BEAR --timeframe 1Day --days 365 \
  --drift -0.15 --volatility 0.35
```

**Choppy/Sideways Market:**
```bash
python generate_market_data.py --symbols CHOP --timeframe 1Day --days 365 \
  --drift 0.0 --volatility 0.25
```

**High Volatility (Crypto-like):**
```bash
python generate_market_data.py --symbols VOLATILE --timeframe 1Day --days 365 \
  --volatility 0.80 --drift 0.50
```

### 2. Multi-Timeframe Analysis

Generate the same period across multiple timeframes:

```bash
SYMBOLS="AAPL MSFT"
START_DATE="2024-01-01"
DAYS=365

for TF in 1Min 5Min 15Min 1Hour 1Day; do
  python generate_market_data.py \
    --symbols $SYMBOLS \
    --timeframe $TF \
    --start-date $START_DATE \
    --days $DAYS \
    --seed 42  # Same seed = correlated price movements
done
```

### 3. Portfolio Correlation Control

Generate correlated assets by using the same seed:

```bash
# Generate 3 correlated stocks
python generate_market_data.py --symbols STOCK1 --timeframe 1Day --days 365 --seed 100
python generate_market_data.py --symbols STOCK2 --timeframe 1Day --days 365 --seed 100
python generate_market_data.py --symbols STOCK3 --timeframe 1Day --days 365 --seed 100

# Generate 3 uncorrelated stocks (no seed = random)
python generate_market_data.py --symbols STOCK4 --timeframe 1Day --days 365
python generate_market_data.py --symbols STOCK5 --timeframe 1Day --days 365
python generate_market_data.py --symbols STOCK6 --timeframe 1Day --days 365
```

### 4. Large-Scale Data Generation

Generate data for backtesting across many symbols:

```bash
# Generate 100 stocks with realistic variety
for i in {1..100}; do
  python generate_market_data.py \
    --symbols "STOCK$i" \
    --timeframe 1Day \
    --days 730 \
    --format parquet
done
```

### 5. Micro-Structure for HFT Testing

Generate ultra-high frequency data:

```bash
# 60 days of 1-minute data with VWAP and trade counts
python generate_market_data.py \
  --symbols SPY QQQ IWM \
  --timeframe 1Min \
  --days 60 \
  --include-vwap \
  --include-trade-count \
  --format parquet
```

## Python API Usage

### Basic Programmatic Usage

```python
from generate_market_data import MarketDataGenerator
import datetime

# Create generator
gen = MarketDataGenerator()

# Generate data
df = gen.generate_data(
    symbol='AAPL',
    start_date=datetime.date(2024, 1, 1),
    end_date=datetime.date(2024, 12, 31),
    timeframe='1Day'
)

# Save
gen.save_to_parquet(df, Path('data'), 'AAPL', '1Day')
```

### Batch Generation with Custom Logic

```python
from generate_market_data import MarketDataGenerator
import datetime
from pathlib import Path

generator = MarketDataGenerator()

# Generate tech sector (high volatility, high growth)
tech_symbols = ['AAPL', 'MSFT', 'GOOGL', 'NVDA', 'META']
for symbol in tech_symbols:
    df = generator.generate_data(
        symbol=symbol,
        start_date=datetime.date(2024, 1, 1),
        end_date=datetime.date(2024, 12, 31),
        timeframe='1Day',
        volatility=generator.rng.uniform(0.25, 0.50),  # Higher volatility
        drift=generator.rng.uniform(0.10, 0.25),       # Higher growth
        avg_volume=generator.rng.integers(5000000, 20000000)
    )
    generator.save_to_parquet(df, Path('data'), symbol, '1Day')

# Generate utility sector (low volatility, low growth)
utility_symbols = ['UTL1', 'UTL2', 'UTL3']
for symbol in utility_symbols:
    df = generator.generate_data(
        symbol=symbol,
        start_date=datetime.date(2024, 1, 1),
        end_date=datetime.date(2024, 12, 31),
        timeframe='1Day',
        volatility=generator.rng.uniform(0.10, 0.20),  # Lower volatility
        drift=generator.rng.uniform(0.02, 0.08),       # Lower growth
        avg_volume=generator.rng.integers(100000, 1000000)
    )
    generator.save_to_parquet(df, Path('data'), symbol, '1Day')
```

### Custom Validation

```python
from generate_market_data import MarketDataGenerator
import datetime

generator = MarketDataGenerator()

df = generator.generate_data(
    symbol='CUSTOM',
    start_date=datetime.date(2024, 1, 1),
    end_date=datetime.date(2024, 12, 31),
    timeframe='1Day'
)

# Built-in validation
is_valid, errors = generator._validate_dataframe(df)
if is_valid:
    print("✓ Data is valid")
else:
    print("✗ Validation errors:")
    for error in errors:
        print(f"  - {error}")

# Custom validation
assert df['close'].min() > 0, "Price must be positive"
assert len(df) >= 252, "Need at least 1 year of daily data"
assert df.index.is_unique, "Timestamps must be unique"
```

## Performance Considerations

### Memory Usage

- Daily data: ~100 KB per symbol per year
- 1-minute data: ~30 MB per symbol per year
- Parquet compression: ~50% smaller than CSV

### Generation Speed

- Daily data: ~1000 bars/second
- Intraday data: ~500 bars/second
- Bottleneck: OHLC generation and validation

### Optimization Tips

```bash
# Generate multiple symbols in parallel (requires GNU parallel)
parallel python generate_market_data.py --symbols {} --timeframe 1Day --days 365 \
  ::: AAPL MSFT GOOGL AMZN META TSLA NVDA AMD INTC

# Use Parquet only (faster than CSV)
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365 --format parquet

# Skip optional columns
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365
# Don't use --include-vwap or --include-trade-count unless needed
```

## Data Quality Validation

### Indicator Readiness

The data is designed to be immediately usable with technical indicators:

```python
import pandas as pd

df = pd.read_parquet('data/parquet/AAPL/1Day.parquet')

# These should work without errors after warmup period
df['EMA_20'] = df['close'].ewm(span=20).mean()
df['EMA_50'] = df['close'].ewm(span=50).mean()

# ATR calculation
high_low = df['high'] - df['low']
high_close = abs(df['high'] - df['close'].shift())
low_close = abs(df['low'] - df['close'].shift())
true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
df['ATR_14'] = true_range.rolling(14).mean()

# ADX (simplified)
df['TR'] = true_range
df['ATR'] = df['TR'].rolling(14).mean()
# ... full ADX calculation

# Verify no NaN in recent data (after warmup)
assert df.iloc[-20:]['EMA_50'].notna().all()
assert df.iloc[-20:]['ATR_14'].notna().all()
```

## Troubleshooting

### Issue: "Insufficient history" warning

**Solution:** Increase `--days` parameter:
```bash
# Need at least 50 bars
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 80
```

### Issue: Data seems too volatile/stable

**Solution:** Adjust volatility parameter:
```bash
# Lower volatility (more stable)
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365 --volatility 0.15

# Higher volatility (more movement)
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365 --volatility 0.50
```

### Issue: Prices drift too much

**Solution:** Adjust drift parameter:
```bash
# Sideways market (no drift)
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365 --drift 0.0

# Strong uptrend
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365 --drift 0.20
```

### Issue: Need reproducible results

**Solution:** Use a fixed seed:
```bash
python generate_market_data.py --symbols AAPL --timeframe 1Day --days 365 --seed 42
```

## Best Practices

1. **Start with daily data** - Easier to work with, faster to generate
2. **Use Parquet format** - Smaller files, faster loading
3. **Generate 1-3 years** - Good balance of data and generation time
4. **Leave parameters random** - More realistic variety for testing
5. **Validate before using** - Run `verify_data.py` after generation
6. **Version your seeds** - Document seeds used for important backtests
7. **Test with multiple runs** - Ensure strategy works on various market conditions

## Integration Examples

### With Backtrader

```python
import backtrader as bt
import pandas as pd

# Load generated data
df = pd.read_parquet('data/parquet/AAPL/1Day.parquet')

# Convert to backtrader format
class PandasData(bt.feeds.PandasData):
    params = (
        ('datetime', None),
        ('open', 'open'),
        ('high', 'high'),
        ('low', 'low'),
        ('close', 'close'),
        ('volume', 'volume'),
        ('openinterest', -1),
    )

data = PandasData(dataname=df)

cerebro = bt.Cerebro()
cerebro.adddata(data)
# ... add strategies
```

### With Zipline

```python
import pandas as pd
from zipline.data import bundles

# Load generated data
df = pd.read_parquet('data/parquet/AAPL/1Day.parquet')

# Zipline expects specific format
df = df.rename(columns={
    'open': 'open',
    'high': 'high',
    'low': 'low',
    'close': 'close',
    'volume': 'volume'
})

# Register as bundle
# ... follow Zipline bundle creation
```

### With TA-Lib

```python
import talib
import pandas as pd

df = pd.read_parquet('data/parquet/AAPL/1Day.parquet')

# TA-Lib works directly with numpy arrays
close = df['close'].values
high = df['high'].values
low = df['low'].values

# Calculate indicators
sma = talib.SMA(close, timeperiod=20)
rsi = talib.RSI(close, timeperiod=14)
macd, signal, hist = talib.MACD(close)
```

## Resources

- [Specs Document](SPECS%20FOR%20SYNTHETIC%20MARKET%20DATA) - Full technical specifications
- [README.md](README.md) - Quick start guide
- [examples.py](examples.py) - Code examples
- [verify_data.py](verify_data.py) - Data validation tool
